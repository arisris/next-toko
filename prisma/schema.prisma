datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
  //shadowDatabaseUrl = env("SHADOW_DATABASE_URL") // Only needed when using a cloud provider that doesn't support the creation of new databases, like Heroku. Learn more: https://pris.ly/migrate-shadow
}

generator client {
  provider = "prisma-client-js"
  //previewFeatures = ["referentialActions"] // You won't need this in Prisma 3.X or higher.
}
generator nexusPrisma {
  provider = "nexus-prisma"
}

enum EnumUserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
}

enum EnumRole {
  USER
  SELLER
  ADMIN
}

enum EnumPostStatus {
  PUBLISH
  DRAFT
  PRIVATE
  DELETED
}

enum EnumPostType {
  BLOGPOST
  PRODUCT
  PAGES
}

enum EnumProductStatus {
  OUTOFSTOCK
  DELETED
  AVAILABLE
  DRAFT
}

enum EnumCommentStatus {
  PUBLISH
  PENDING 
  REJECTED
  DELETED
}

enum EnumWalletMutationType {
  TOPUP
  TRANSFER
  PURCHASE
  DEFAULT
}

model Users {
  id             Int              @id @default(autoincrement())
  name           String           @unique
  password       String
  email          String           @unique
  status         EnumUserStatus   @default(INACTIVE)
  emailVerified  Boolean?         @default(false)
  phoneNumber    String?
  image          String?          @default("https://0.gravatar.com/avatar/me?s=96") @db.Text
  role           EnumRole?        @default(USER)
  createdAt      DateTime?        @default(now())
  updatedAt      DateTime         @updatedAt
  socialAccounts SocialAccounts[]
  posts          Posts[]
  comments       Comments[]
  commentLikes   CommentLikes[]
  postLikes      PostLikes[]
  wallet         Wallet?          @relation(fields: [walletId], references: [id])
  walletId       Int?
}

model SocialAccounts {
  id           Int    @id @default(autoincrement())
  provider     String
  token        String @db.Text
  refreshToken String @db.Text
  userId       Int?
  user         Users? @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Posts {
  id              Int               @id @default(autoincrement())
  type            EnumPostType      @default(BLOGPOST)
  name            String            @db.VarChar(255)
  image           String?           @db.Text
  body            String?           @db.LongText
  tags            Tags[]
  categories      Categories[]
  productVariants ProductVariants[]
  comments        Comments[]
  status          EnumPostStatus?   @default(DRAFT)
  authorId        Int?
  author          Users?            @relation(fields: [authorId], references: [id], onDelete: Cascade)
  createdAt       DateTime?         @default(now())
  updatedAt       DateTime          @updatedAt
  postLikes       PostLikes[]
}

model PostLikes {
  id       Int     @id @default(autoincrement())
  authorId Int?
  author   Users?  @relation(fields: [authorId], references: [id], onDelete: Cascade)
  like     Boolean
  postId   Int?
  post     Posts?  @relation(fields: [postId], references: [id], onDelete: Cascade)
}

model Categories {
  id          Int          @id @default(autoincrement())
  type        EnumPostType @default(BLOGPOST)
  name        String
  description String?      @db.Text
  posts       Posts[]
}

model Tags {
  id          Int          @id @default(autoincrement())
  type        EnumPostType @default(BLOGPOST)
  name        String
  description String?      @db.Text
  posts       Posts[]
}

model ProductVariants {
  id          Int               @id @default(autoincrement())
  type        String?           @default("default")
  status      EnumProductStatus @default(DRAFT)
  isMain      Boolean?          @default(false)
  name        String            @db.VarChar(255)
  description String            @db.Text
  price       Int?              @default(0)
  stock       Int?              @default(0)
  image       String?           @db.Text
  products    Posts?            @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId   Int?
}

model Comments {
  id        Int                @id @default(autoincrement())
  status    EnumCommentStatus? @default(PENDING)
  body      String?            @db.Text
  authorId  Int?
  author    Users?             @relation(fields: [authorId], references: [id], onDelete: Cascade)
  postId    Int?
  post      Posts?             @relation(fields: [postId], references: [id], onDelete: Cascade)
  comments  Comments[]         @relation("CommentReplies")
  comment   Comments?          @relation("CommentReplies", fields: [commentId], references: [id])
  commentId Int?
  likes     CommentLikes[]
}

model CommentLikes {
  id        Int       @id @default(autoincrement())
  authorId  Int?
  author    Users?    @relation(fields: [authorId], references: [id], onDelete: Cascade)
  like      Boolean
  commentId Int?
  comment   Comments? @relation(fields: [commentId], references: [id], onDelete: Cascade)
}

// todo wallet system
model Wallet {
  id         Int               @id @default(autoincrement())
  users      Users[]
  mutations  WalletMutations[]
  amount     Int?              @default(0)
  isVerified Boolean?          @default(false)
  verifiedAt DateTime?
  createdAt  DateTime?         @default(now())
  updatedAt  DateTime?         @updatedAt
}

model WalletMutations {
  id         Int                    @id @default(autoincrement())
  type       EnumWalletMutationType @default(DEFAULT)
  walletId   Int?
  wallet     Wallet?                @relation(fields: [walletId], references: [id], onDelete: Cascade)
  amount     Int?                   @default(0)
  isVerified Boolean?               @default(false)
  verifiedAt DateTime?
  createdAt  DateTime?              @default(now())
  updatedAt  DateTime?              @updatedAt
}
