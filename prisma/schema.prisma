datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
  //shadowDatabaseUrl = env("SHADOW_DATABASE_URL") // Only needed when using a cloud provider that doesn't support the creation of new databases, like Heroku. Learn more: https://pris.ly/migrate-shadow
}

generator client {
  provider = "prisma-client-js"
  //previewFeatures = ["referentialActions"] // You won't need this in Prisma 3.X or higher.
}

enum Role {
  USER
  SELLER
  ADMIN
}

enum PostStatus {
  PUBLISH
  DRAFT
  PRIVATE
  DELETED
}

enum PostType {
  BLOGPOST
  PRODUCT
}

enum ProductStatus {
  OUTOFSTOCK
  DELETED
  AVAILABLE
  DRAFT
}

enum CommentStatus {
  PUBLISH
  PENDING
  REJECTED
  DELETED
}

model Users {
  id             String           @id @default(cuid())
  username       String           @unique
  password       String
  email          String           @unique
  emailVerified  Boolean?         @default(false)
  phoneNumber    String?
  photo          String?          @default("https://0.gravatar.com/avatar/me?s=96") @db.Text
  role           Role?            @default(USER)
  createdAt      DateTime?        @default(now())
  updatedAt      DateTime         @updatedAt
  socialAccounts SocialAccounts[]
  posts          Posts[]
  comments       Comments[]
  commentLikes   CommentLikes[]
  postLikes      PostLikes[]
}

model SocialAccounts {
  id           String  @id @default(cuid())
  provider     String
  token        String  @db.Text
  refreshToken String  @db.Text
  userId       String?
  user         Users?  @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Posts {
  id              String            @id @default(cuid())
  type            PostType          @default(BLOGPOST)
  name            String
  image           String?           @db.Text
  body            String?           @db.LongText
  tags            Tags[]
  categories      Categories[]
  productVariants ProductVariants[]
  comments        Comments[]
  status          PostStatus?       @default(DRAFT)
  authorId        String?
  author          Users?            @relation(fields: [authorId], references: [id], onDelete: Cascade)
  createdAt       DateTime?         @default(now())
  updatedAt       DateTime          @updatedAt
  postLikes       PostLikes[]
}

model PostLikes {
  id       String  @id @default(cuid())
  authorId String?
  author   Users?  @relation(fields: [authorId], references: [id], onDelete: Cascade)
  like     Boolean
  postId   String?
  post     Posts?  @relation(fields: [postId], references: [id], onDelete: Cascade)
}

model Categories {
  id          String   @id @default(cuid())
  type        PostType @default(BLOGPOST)
  name        String
  description String?  @db.Text
  posts       Posts[]
}

model Tags {
  id          String   @id @default(cuid())
  type        PostType @default(BLOGPOST)
  name        String
  description String?  @db.Text
  posts       Posts[]
}

model ProductVariants {
  id          String        @id @default(cuid())
  type        PostType      @default(PRODUCT)
  status      ProductStatus @default(DRAFT)
  name        String
  description String        @db.Text
  price       Int?          @default(0)
  stock       Int?          @default(0)
  image       String?       @db.Text
  products    Posts?        @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId   String?
}

model Comments {
  id        String         @id @default(cuid())
  status    CommentStatus? @default(PENDING)
  body      String?        @db.Text
  authorId  String?
  author    Users?         @relation(fields: [authorId], references: [id], onDelete: Cascade)
  postId    String?
  post      Posts?         @relation(fields: [postId], references: [id], onDelete: Cascade)
  comments  Comments[]     @relation("CommentReplies")
  comment   Comments?      @relation("CommentReplies", fields: [commentId], references: [id])
  commentId String?
  likes     CommentLikes[]
}

model CommentLikes {
  id        String    @id @default(cuid())
  authorId  String?
  author    Users?    @relation(fields: [authorId], references: [id], onDelete: Cascade)
  like      Boolean
  commentId String?
  comment   Comments? @relation(fields: [commentId], references: [id], onDelete: Cascade)
}
